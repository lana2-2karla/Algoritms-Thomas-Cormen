# 🧠 O PAPEL DOS ALGORITMOS NA COMPUTAÇÃO

Este capítulo busca responder perguntas fundamentais:

- O que são algoritmos?
- Por que vale a pena estudá-los?
- Qual o papel dos algoritmos comparado com outras tecnologias da computação?

---

## 1.1 ALGORITMOS

### 📌 O que é um algoritmo?

Um algoritmo é uma sequência de passos bem definidos para resolver um problema.

 - Ele recebe uma entrada (input), processa e gera uma saída (output).

> Exemplo: um algoritmo pode pegar uma lista de números bagunçados e devolvê-los em ordem crescente.

---

### 🎯 Qual é o papel dos algoritmos na computação?

 - Eles são o cérebro por trás dos programas.

 - Sem algoritmos, não existe software funcionando de forma lógica e eficiente.

 - Eles ajudam o computador a tomar decisões, organizar dados, encontrar caminhos, proteger informações, etc.

---

### 📋 Por que estudar algoritmos?

- Porque eles tornam a resolução de problemas mais rápida, eficiente e correta.

- Eles permitem que os programas façam tarefas complexas usando menos tempo e recursos.

---

## 🔢 Exemplo: Ordenar números

**Problema**: ordenar uma sequência de números em ordem crescente (ou seja, de menor para maior).

**Definição formal:**

- **Entrada**: uma sequência com `n` números: 〈a₁, a₂, ..., aₙ〉
- **Saída**: uma permutação (reorganização) da sequência: 〈a₁’, a₂’, ..., aₙ’〉 tal que:  
  `a₁’ ≤ a₂’ ≤ ... ≤ aₙ’`

---

### 📌 Exemplo concreto:

- **Entrada**: 〈31, 41, 59, 26, 41, 58〉
- **Saída esperada**: 〈26, 31, 41, 41, 58, 59〉

Esse conjunto específico de números é chamado de **instância do problema de ordenação**.

> 🧩 Em geral, uma **instância de problema** é a entrada que cumpre os critérios do problema e é usada para gerar uma solução.

O problema é resolvido com um algoritmo de ordenação, como o Bubble Sort, Merge Sort, Quick Sort, etc.

---

## 🔁 A importância da ordenação

Ordenar dados é uma operação fundamental na computação, porque:

- Muitos programas usam ordenação como etapa intermediária.
- Existem muitos algoritmos de ordenação diferentes, e o melhor depende de:
  - Quantidade de itens
  - Quão ordenados os dados já estão
  - Restrições sobre os dados
  - Arquitetura do computador
  - Tipo de armazenamento: RAM, disco, fita, etc.

---

## ✔️ O que é um algoritmo correto?

Um algoritmo é **correto** quando:

- Ele sempre **para** (termina) para qualquer entrada,
- E sempre dá a **resposta certa**.

Se isso acontecer, dizemos que o algoritmo **resolve o problema computacional**.

Se não parar ou der respostas erradas em certos casos, ele é **incorreto**.

> ⚠️ **Curiosidade**: Às vezes, algoritmos incorretos ainda podem ser úteis, se conseguirmos controlar a taxa de erro.  
> 📌 Exemplo disso está no Capítulo 31, com algoritmos para encontrar grandes números primos.

Mas, geralmente, focamos em algoritmos corretos.

---

## 💬 Como especificar um algoritmo?

Pode ser em:

- Linguagem comum (português ou inglês técnico),
- Um programa de computador,
- Um projeto de hardware (como circuitos).

A única exigência: a descrição precisa ser **precisa**, explicando **passo a passo** o procedimento a ser seguido.

---

## ❓ Que tipos de problemas são resolvidos por algoritmos?

A ordenação é só um entre muitos problemas resolvidos com algoritmos.

Vamos ver exemplos práticos:

---

## 🧬 Projeto Genoma Humano

**Objetivo**: identificar todos os ~100.000 genes do DNA humano e os 3 bilhões de pares de bases químicas.

**Etapas envolvem**:

- Identificação  
- Sequenciamento  
- Armazenamento  
- Análise

🔧 Todas essas etapas usam algoritmos sofisticados.

> 💡 Embora o livro não ensine biologia, ele mostra ideias que ajudam cientistas a usar recursos de tempo e dinheiro com eficiência.

---

## 🌐 Internet

Com a Internet, temos que:

- Acessar grandes volumes de dados rapidamente,
- Encontrar informações específicas (buscadores),
- Roteá-las por boas rotas.

📌 Exemplos de problemas resolvidos com algoritmos:

- Roteamento de dados (Capítulo 24)
- Buscas eficientes (Capítulos 11 e 32)

---

## 🛒 Comércio eletrônico

Requer segurança de dados como:

- Cartões de crédito  
- Senhas  
- Extratos bancários

**Algoritmos usados aqui**:

- Criptografia de chave pública  
- Assinaturas digitais (Capítulo 31)

---

## 🏭 Indústria e logística

Problemas de alocação de recursos:

- Onde colocar poços de petróleo?
- Onde fazer propaganda política?
- Como escalar tripulações de avião?
- Como melhorar atendimento de clientes na internet?

Esses problemas são resolvidos com **programação linear** (Capítulo 29).

---

## 🧮 Outros exemplos clássicos de problemas resolvidos com algoritmos

### 📍 Rota mais curta em um mapa rodoviário

- **Modelo**: grafo  
- **Solução**: encontrar o caminho mínimo entre dois vértices (Capítulo 24)

### 📍 Subsequência comum mais longa

- Duas sequências X e Y → encontrar a maior subsequência comum  
- **Aplicação**: comparar cadeias de DNA  
- **Solução eficiente**: programação dinâmica (Capítulo 15)

### 📍 Ordenação topológica

- Peças de um projeto dependem umas das outras.  
- Precisamos ordená-las para que cada uma apareça antes de qualquer peça que dependa dela.  
- Muito mais rápido do que testar todas as `n!` combinações possíveis (Capítulo 22)

### 📍 Envoltória convexa

- Dados `n` pontos no plano, encontrar o menor polígono convexo que os envolve.  
- Exemplo: como se passássemos um elástico em volta dos pontos (Capítulo 33)

---

## 🧠 Dois pontos importantes sobre problemas resolvidos por algoritmos

- Existem muitas soluções possíveis, mas só algumas realmente resolvem bem o problema.
- Esses problemas têm impacto prático real – seja economizando tempo, dinheiro ou energia.

> Exemplo: encontrar caminhos mais curtos economiza combustível, tempo e dinheiro.

---

## 📊 Problemas sem soluções fáceis

Nem todo problema tem soluções fáceis de identificar.

### Exemplo: Transformada Discreta de Fourier (TDF)

- Converte dados do domínio do tempo para o domínio da frequência.
- Ajuda a analisar sinais.
- É útil também em compressão de dados e multiplicação de polinômios.

💡 **Solução eficiente**: FFT (Fast Fourier Transform) no Capítulo 30.

---

## 🧱 Estruturas de dados

São formas de armazenar e organizar dados para facilitar o acesso e a modificação.

### 📌 Exemplo simples

Se você tem uma lista de tarefas, pode guardar isso como:

- **Uma lista (array)** → `[“Estudar”, “Comer”, “Dormir”]`
- **Uma fila (queue)** → tarefas são feitas na ordem em que chegam
- **Uma pilha (stack)** → a tarefa mais recente é feita primeiro
- **Um dicionário (mapa)** → associando tarefas com horários

Não existe uma estrutura única ideal para tudo.  
Por isso, precisamos:

- Entender os pontos fortes e fracos de cada estrutura  
- Escolher a mais adequada para o problema

---

## 🛠 Técnicas de projeto de algoritmos

Além de usar algoritmos já prontos (tipo receita de bolo), às vezes você precisa criar os seus próprios algoritmos.

### 📌 Para isso, existem técnicas que te ajudam a pensar na solução:

- **Divisão e conquista** → quebra o problema em partes menores
- **Programação dinâmica** → guarda resultados para não repetir cálculos
- **Análise amortizada** → mede o custo médio de várias operações, não só uma

### 🎯 Você aprende essas técnicas para:

- Criar seus próprios algoritmos  
- Provar que eles funcionam corretamente  
- Avaliar se eles são rápidos ou lentos

---

## ❌ Problemas difíceis: NP-completos (Cap. 34)

Alguns problemas são muito difíceis. Tão difíceis que:

- Ninguém até hoje achou uma solução rápida
- E ninguém conseguiu provar que é impossível resolver rápido 😅

Esses problemas são chamados de **NP-completos**.

### 📌 Exemplo: O Problema do Caixeiro Viajante

Um caminhão precisa passar por várias cidades e voltar pro depósito gastando a menor distância possível.

Parece simples, mas o número de possibilidades **explode** à medida que o número de cidades cresce.

### 💡 Como lidamos com isso?

Como não temos solução rápida para esse tipo de problema, usamos:

- **Algoritmos de aproximação**  
  → nos dão uma **boa solução**, mesmo que não seja a **perfeita**

### 🧠 Por que é importante saber se um problema é NP-completo?

Porque procurar uma solução perfeita pode ser **perda de tempo**.

Sabendo disso, você pode:

- Aceitar uma **boa solução aproximada**
- Ou tentar **simplificar o problema**

---

## 🔄 Paralelismo

Antes: a velocidade do processador aumentava com o tempo.

Hoje: há um **limite físico** (calor e densidade de energia).

### Solução moderna: múltiplos núcleos de processamento no mesmo chip.

📌 Para tirar vantagem disso, precisamos de **algoritmos paralelos**.

- Capítulo 27: Algoritmos “multithread” (vários fluxos de execução)
- Usados até em programas como os de **campeonatos de xadrez**
